```# patroling/goal_assigner_node.py
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from action_msgs.msg import GoalStatus
import random

from nav2_msgs.action import NavigateToPose
from geometry_msgs.msg import PoseStamped, Point
from std_msgs.msg import String
from visualization_msgs.msg import MarkerArray, Marker

# Import the RobotManager class
from .robot_manager import RobotManager
from nav_msgs.msg import Odometry  # Import Odometry message
from functools import partial

from .points_to_monitor import get_random_points_to_monitor_near_obstacles2, Atransform

import numpy as np
from PIL import Image 
from sensor_msgs.msg import Image as msgimg
from std_msgs.msg._float64_multi_array import Float64MultiArray
from std_msgs.msg import MultiArrayDimension

import yaml
import os
from cv_bridge import CvBridge
import cv2
from icecream import ic
from datetime import datetime
import json
import threading
# Import the custom service
from patrolling_interfaces.srv import SendRobotToObject  # Adjusted import path

class GoalAssignerNode(Node):

    def __init__(self):
        super().__init__('goal_assigner')

        # Default parameters
        self.declare_parameter('robot_names', ['robot1'])
        self.declare_parameter('world_frame', 'map')
        self.declare_parameter('status_check_interval', 2.0)  # in seconds
        self.declare_parameter('map_yaml_file', 'config/map.yaml')
        self.declare_parameter('map_file', 'config/map.pgm')
        self.declare_parameter('objects_file', 'config/objects.yaml')  # Parameter for objects file

        # Get parameters
        self.robot_names = self.get_parameter('robot_names').get_parameter_value().string_array_value
        self.world_frame = self.get_parameter('world_frame').get_parameter_value().string_value
        self.status_check_interval = self.get_parameter('status_check_interval').get_parameter_value().double_value
        self.map_yaml_file = self.get_parameter('map_yaml_file').get_parameter_value().string_value
        self.map_file = self.get_parameter('map_file').get_parameter_value().string_value
        self.objects_file = self.get_parameter('objects_file').get_parameter_value().string_value  # Get objects file

        # Load the map metadata
        with open(self.map_yaml_file, 'r') as yaml_file:
            map_yaml = yaml.safe_load(yaml_file)
        self.resolution = map_yaml['resolution']
        self.origin = map_yaml['origin']

        # Load the occupancy grid
        self.occupancy_grid = self.pgm2occupancy(self.map_file)
        self.width, self.height = self.occupancy_grid.shape
        self.get_logger().info(f"{self.origin, self.height, self.width}")

        # Load monitoring points
        # TODO: TO RUN AFER A CERTAIN TIME PERIODICALLY
        sampled_grid_points = get_random_points_to_monitor_near_obstacles2(occupancy_grid=self.occupancy_grid)
        self.monitoring_points = sampled_grid_points
        sampled_grid_points = Atransform(sampled_grid_points, self.occupancy_grid.shape, self.get_logger())
        self.monitoring_points_world = self.convert_grid_to_world(sampled_grid_points)
        self.get_logger().info(f"Loaded {len(self.monitoring_points)} monitoring points.")
        # Initialize RobotManager with occupancy grid and monitoring points
        self.robot_manager = RobotManager(self.occupancy_grid, self.monitoring_points, logger=self.get_logger())

        # Initialize robot data structures
        self.robots = {}
        for robot_name in self.robot_names:
            action_topic = f'/{robot_name}/navigate_to_pose'
            action_client = ActionClient(self, NavigateToPose, action_topic)
            
            # Assign a unique color to each robot
            color = self.assign_unique_color(robot_name)
            
            # Create a Marker publisher for each robot with a robot-specific topic
            marker_topic = f'/{robot_name}/monitoring_points_marker'
            marker_publisher = self.create_publisher(MarkerArray, marker_topic, 10)

            self.robots[robot_name] = {
                'action_client': action_client,
                'current_point': None,
                'assigned_point': None,
                'goal_handle': None,
                'status': GoalStatus.STATUS_UNKNOWN,  # Initialize with UNKNOWN status
                'marker_publisher': marker_publisher,  # Publisher for robot's monitoring points
                'color': color,  # Unique color for the robot
                'monitoring_points': []  # List to store this robot's monitoring points
            }

        # Initialize robots in RobotManager
        for robot_name in self.robot_names:
            initial_position = self.get_random_free_position()
            grid_position = self.world_to_grid(initial_position)
            self.robot_manager.add_robot(robot_name, 'patrolling', initial_position=grid_position)
            self.get_logger().info(f'Added robot {robot_name} at grid position {grid_position}')

        # # Set map parameters in RobotManager for coordinate transformations
        # self.robot_manager.set_map_parameters(
        #     resolution=self.resolution,
        #     origin=self.origin,
        #     height=self.height
        # )

        # Divide the available space among robots
        self.robot_manager.launch()

        # Assign monitoring points to robots
        self.robot_manager.assign_monitoring_points_to_robots()

        # Retrieve and store each robot's monitoring points
        for robot_name in self.robot_names:
            robot_obj = self.robot_manager.get_robot_by_id(robot_name)
            if robot_obj:
                world_points = robot_obj.assigned_points  # Assuming this attribute exists
                # grid_points = Atransform(np.array(grid_points), self.occupancy_grid.shape, self.get_logger())

                # world_points = self.convert_grid_to_world(grid_points)

                self.robots[robot_name]['monitoring_points'] = world_points
                self.get_logger().info(f'Assigned {len(world_points)} monitoring points to {robot_name}')

        # Publisher for current points
        self.current_points_publisher = self.create_publisher(String, 'current_points', 10)
        self.publish_current_points_timer = self.create_timer(1.0, self.publish_current_points)

        # Timer for periodic status checks
        self.status_check_timer = self.create_timer(self.status_check_interval, self.check_goal_statuses)
        self.image_data_sub = self.create_subscription(msgimg,'/robot3/image_data',self.image_callback,2)
        self.bridge = CvBridge()
        self.image_lock = threading.Lock()
        self.latest_image = None

        self.depth_image_data_sub = self.create_subscription(Float64MultiArray,'/robot3/depth_image_data',self.depth_image_callback,2)
        self.latest_depth_image = None
        # Create the service to send robots to objects
        self.send_robot_service = self.create_service(
            SendRobotToObject,
            'send_robot_to_object',
            self.send_robot_to_object_callback
        )

        # Load objects from the configuration file
        self.load_objects(self.objects_file)
        # ------------------- Integration for Rviz Visualization -------------------


        # Timer to publish markers periodically
        self.marker_publish_rate_each = 1.0  # seconds
        self.marker_publish_timer_each = self.create_timer(self.marker_publish_rate_each, self.publish_markers_each)

        # Publisher for monitoring points markers
        self.pub_marker_points = self.create_publisher(MarkerArray, 'visualization_marker_array_points', 10)

        # Timer to publish markers periodically
        self.marker_publish_rate = 2.0  # seconds
        self.marker_publish_timer = self.create_timer(self.marker_publish_rate, self.publish_markers)
        # Flag to ensure markers are published only once if the points don't change
        self.markers_published = False

        # --------------------------------------------------------------------------

        # ------------------- Integration for Robot-Specific Markers -------------------

        # # Timer to publish robot markers periodically
        # self.robot_marker_publish_rate = 1.0  # seconds
        # self.robot_marker_publish_timer = self.create_timer(self.robot_marker_publish_rate, self.publish_robot_markers)

        # --------------------------------------------------------------------------
        # Create subscribers for each robot's odom
        self.latest_positions = {robot: None for robot in self.robot_names}

        self.odom_subscribers = {}
        for robot in self.robot_names:
            topic_name = f'/{robot}/odom'
            self.odom_subscribers[robot] = self.create_subscription(
                Odometry,
                topic_name,
                partial(self.odom_callback, robot_name=robot),
                10  # QoS history depth
            )
            self.get_logger().info(f'Subscribed to {topic_name}')

        # Optionally, set up a timer to periodically print the latest positions
        # self.create_timer(5.0, self.update_latest_postion)  # Every 5 seconds

    def odom_callback(self, msg: Odometry, robot_name: str):
        """
        Callback function for odometry messages.
        Stores the latest position of the robot.
        """
        position = msg.pose.pose.position
        self.latest_positions[robot_name] = position
        self.get_logger().debug(
            f'Received odom for {robot_name}: Position -> x: {position.x}, y: {position.y}, z: {position.z}'
        )

    def update_latest_postion(self):
        """
        Prints the latest known positions of all robots.
        """
        for robot, position in self.latest_positions.items():
            if position:
                self.get_logger().info(
                    f'{robot} Position -> x: {position.x:.2f}, y: {position.y:.2f}, z: {position.z:.2f}'
                )
            else:
                self.get_logger().info(f'{robot} Position -> Not received yet.')
    def image_callback(self, msg):
        # self.get_logger().info("Depth image callback received")

        """Callback function for image data"""
        try:
            # Convert ROS Image message to OpenCV format
            cv_image = self.bridge.imgmsg_to_cv2(msg, desired_encoding='bgr8')

            # Store the image thread-safely
            with self.image_lock:
                self.latest_image = cv_image.copy()

            # Optional: Display the image
        #     cv2.imshow("Robot  image Camera", cv_image)
        #     cv2.waitKey(1)

        #     self.get_logger().debug(f"Received image with shape: {cv_image.shape}")

        except Exception as e:
            self.get_logger().error(f'Error processing image: {str(e)}')


    def depth_image_callback(self,msg):
        self.get_logger().info("Depth image callback received")
        # Get the dimensions from the message layout
        height = msg.layout.dim[0].size
        width = msg.layout.dim[1].size
        # self.get_logger().info(f"width {width} height {height}")
        # Convert the flat array back to 2D
        depth_data = np.array(msg.data)
        # self.get_logger().info(f"width {width} height {depth_data}")

        # Replace the special value with NaN
        depth_data[depth_data == -999.999] = np.nan

        # Reshape to original dimensions
        depth_image = depth_data.reshape((height, width))
        self.latest_depth_image = depth_image.copy()
        # Now depth_image is a 2D numpy array with the original depth values
        # You can process it as needed

        # except Exception as e:
        #     self.get_logger().error(f'Error processing image: {str(e)}')

    def assign_unique_color(self, robot_name):
        """
        Assigns a unique color to each robot based on its name.
        Customize the colors as needed.
        """
        color_map = {
            'robot1': (1.0, 0.0, 0.0, 1.0),  # Red
            'robot2': (0.0, 1.0, 0.0, 1.0),  # Green
            'robot3': (0.0, 0.0, 1.0, 1.0),  # Blue
            'robot4': (1.0, 1.0, 0.0, 1.0),  # Yellow
            'robot5': (1.0, 0.0, 1.0, 1.0),  # Magenta
            # Add more robots and colors as needed
        }
        return color_map.get(robot_name, (0.5, 0.5, 0.5, 1.0))  # Default to gray


    def publish_robot_markers(self):
        """
        Publishes markers for each robot on their respective topics with unique colors.
        """
        for robot_name, data in self.robots.items():
            marker = Marker()
            marker.header.frame_id = self.world_frame
            marker.header.stamp = self.get_clock().now().to_msg()
            marker.ns = f"{robot_name}_namespace"
            marker.id = 0  # Unique ID per robot
            marker.type = Marker.ARROW  # Use ARROW to indicate direction
            marker.action = Marker.ADD
            marker.pose.orientation.w = 1.0
            marker.scale.x = 1.0  # Arrow length
            marker.scale.y = 0.2  # Arrow width
            marker.scale.z = 0.2  # Arrow height
            marker.color.r, marker.color.g, marker.color.b, marker.color.a = data['color']

            # Determine the position to display the marker
            if data['assigned_point']:
                # If there's an assigned goal, show the goal position
                position = data['assigned_point']
                marker.pose.position.x = float(position.x)
                marker.pose.position.y = float(position.y)
                marker.pose.position.z = 0.0
                # Orientation can be set based on the robot's heading if available
            elif data['current_point']:
                # Else, show the current position
                position = data['current_point']
                marker.pose.position.x = float(position.x)
                marker.pose.position.y = float(position.y)
                marker.pose.position.z = 0.0
            else:
                # If no position is available, place the marker at origin
                marker.pose.position.x = 0.0
                marker.pose.position.y = 0.0
                marker.pose.position.z = 0.0

            # Optionally, set the orientation based on the robot's heading
            # For simplicity, we set it to face forward
            marker.pose.orientation.w = 1.0

            # Publish the marker
            data['marker_publisher'].publish(marker)

    # ... [Rest of your existing methods] ...

    def convert_grid_to_world(self, grid_points):
        """
        Converts grid indices to world coordinates.
        :param grid_points: numpy array of shape (N, 2) with (row, col) indices
        :return: List of tuples [(x1, y1), (x2, y2), ...]
        """
        world_points = []
        for point in grid_points:
            row, col = point
            x = row * self.resolution + self.origin[0]
            y = self.origin[1] + col * self.resolution  # Corrected y-coordinate calculation
            world_points.append((x, y))
        return world_points

    def world_to_grid(self, world_point):
        """
        Converts world coordinates to grid indices.
        :param world_point: [x, y] in world coordinates
        :return: [row, col] in grid indices
        """
        x, y = world_point
        col = int((x - self.origin[0]) / self.resolution)
        row = int((y - self.origin[1]) / self.resolution)
        return [row, col]

    def load_monitoring_points(self):
        """
        Loads monitoring points. Currently, points are loaded during initialization.
        This method can be expanded to dynamically load points if needed.
        """
        pass  # Points are loaded during initialization

    def load_objects(self, objects_file):
        """
        Loads objects from a YAML file.
        :param objects_file: Path to the YAML file
        """
        try:
            with open(objects_file, 'r') as file:
                data = yaml.safe_load(file)
                self.objects = data.get('objects', {})
                self.get_logger().info(f"Loaded objects from {objects_file}")
        except Exception as e:
            self.get_logger().error(f"Failed to load objects: {e}")
            self.objects = {}

    def send_robot_to_object_callback(self, request, response):
        """
        Service callback to send a robot to a specified object.
        """
        robot_name = request.robot_name
        object_name = request.object_name

        if robot_name not in self.robot_names:
            response.success = False
            response.message = f"Robot {robot_name} is not available."
            return response

        if object_name not in self.objects:
            response.success = False
            response.message = f"Object {object_name} is not found."
            return response

        # Get object position
        position = self.objects[object_name]
        self.get_logger().info(f"Sending {robot_name} to {object_name} at position {position}")

        # Create a PoseStamped goal
        pose = PoseStamped()
        pose.header.frame_id = self.world_frame
        pose.header.stamp = self.get_clock().now().to_msg()
        pose.pose.position.x = float(position['x'])
        pose.pose.position.y = float(position['y'])
        pose.pose.position.z = 0.0
        pose.pose.orientation.w = 1.0

        # Send goal to the robot
        self.send_goal_to_robot(robot_name, pose)

        # Update robot's state to 'working' to prevent patrol goal assignments
        robot_obj = self.robot_manager.get_robot_by_id(robot_name)
        if robot_obj:
            x,y = self.latest_positions[robot_name].x,self.latest_positions[robot_name].y
            robot_obj.position = x,y
            robot_obj.change_state('working')
            self.robot_manager._divide_available_space()

            self.get_logger().info(f"Robot {robot_name} state changed to 'working'.")

        response.success = True
        response.message = f"{robot_name} is going to {object_name}."
        return response

    def send_goal_to_robot(self, robot_name, pose):
        """
        Sends a navigation goal to a specified robot.
        """
        robot = self.robots[robot_name]
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        action_client = robot['action_client']
        action_topic = f'/{robot_name}/navigate_to_pose'

        if not action_client.wait_for_server(timeout_sec=5.0):
            self.get_logger().error(f'Action server not available for {robot_name} at {action_topic}')
            return

        self.get_logger().info(f'Sending external goal to {robot_name}')
        send_goal_future = action_client.send_goal_async(
            goal_msg,
            feedback_callback=lambda feedback: self.feedback_callback(robot_name, feedback)
        )
        send_goal_future.add_done_callback(lambda future: self.goal_response_callback(robot_name, future))

        # Update robot status to reflect that it's executing an external goal
        robot['status'] = GoalStatus.STATUS_ACCEPTED
        robot['assigned_point'] = pose.pose.position  # Assign the external goal
        robot['current_point'] = None

    def pgm2occupancy(self, pgm_file):
        """
        Converts a PGM file to an occupancy grid.
        Free space: 0
        Obstacles: 1
        """
        img = Image.open(pgm_file)
        img = img.convert('L')  # 'L' mode is for grayscale
        img_array = np.array(img) / 255.0  # Normalize pixel values to [0, 1]
        occupancy_grid = np.zeros_like(img_array, dtype=int)
        occupancy_grid[img_array > 0.9] = 0  # Free space
        occupancy_grid[img_array <= 0.9] = 1  # Obstacles
        return occupancy_grid

    def get_random_free_position(self):
        """
        Retrieves a random free position from the occupancy grid.
        :return: [x, y] in world coordinates
        """
        free_space_indices = np.argwhere(self.occupancy_grid == 0)
        if len(free_space_indices) == 0:
            self.get_logger().error('No free space available in the occupancy grid.')
            return [0, 0]
        random_index = random.choice(free_space_indices)
        row, col = random_index
        x = col * self.resolution + self.origin[0]
        y = self.origin[1] + row * self.resolution  # Corrected y-coordinate calculation
        return [x, y]

    def publish_current_points(self):
        """
        Publishes the current points and their assignments to a ROS topic.
        """
        status_messages = []
        for robot_name, data in self.robots.items():
            status = data['status']
            status_str = self.get_status_string(status) if status is not None else 'NO_STATUS'
            current_point = data['current_point']
            assigned_point = data['assigned_point']

            status_messages.append(
                f'{robot_name}: current={current_point}, '
                f'assigned={assigned_point}, status={status_str}'
            )

        msg = String()
        msg.data = ' | '.join(status_messages)
        self.current_points_publisher.publish(msg)

    def check_goal_statuses(self):
        """
        Timer callback to periodically check the status of each robot's goal.
        Assign new goals if necessary based on the current status.
        """
        for robot_name, data in self.robots.items():
            status = data['status']
            goal_handle = data['goal_handle']

            # Get robot object
            robot_obj = self.robot_manager.get_robot_by_id(robot_name)
            if not robot_obj:
                self.get_logger().error(f'Robot {robot_name} not found in RobotManager.')
                continue

            # Skip robots that are not in 'patrolling' state
            if robot_obj.state != 'patrolling':
                self.get_logger().debug(f'Robot {robot_name} is in state {robot_obj.state}. Skipping goal assignment.')
                continue

            # Log current status
            status_str = self.get_status_string(status) if status is not None else 'NO_STATUS'
            self.get_logger().debug(f'[{robot_name}] Current goal status: {status_str}')

            # self.saving_data(status=status,robot_name=robot_name)
            if status in [
                GoalStatus.STATUS_SUCCEEDED,
                GoalStatus.STATUS_ABORTED,
                GoalStatus.STATUS_CANCELED,
                GoalStatus.STATUS_UNKNOWN,
            ]:
                if status == GoalStatus.STATUS_SUCCEEDED:
                    self.get_logger().info(f'savingsavingsaving')

                    self.saving_data(robot_name=robot_name,robot_obj=robot_obj)

                self.get_logger().info(f'Assigning new patrol goal to {robot_name}')
                self.assign_new_monitoring_goal(robot_name)

            elif status in [GoalStatus.STATUS_ACCEPTED, GoalStatus.STATUS_EXECUTING]:
                # Robot is on the way; do nothing
                pass
            else:
                # Handle other statuses if necessary
                pass

    def saving_data(self, robot_name, robot_obj):
        x, y, z, w = robot_obj.current_goal
        save_dir = "/home/vunknow/patroling_data/images"
        depth_dir = "/home/vunknow/patroling_data/depth_data"  # Directory for NPZ files
        os.makedirs(save_dir, exist_ok=True)
        os.makedirs(depth_dir, exist_ok=True)

        if (self.latest_depth_image is not None) and (self.latest_image is not None):
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            image_path = f"{save_dir}/images_{robot_name}_{timestamp}.jpg"
            depth_npz_path = f"{depth_dir}/depth_data_{robot_name}_{timestamp}.npy"

            # Save RGB image as JPG
            cv2.imwrite(image_path, self.latest_image)

            # Save depth data as NPZ
            np.save(depth_npz_path, self.latest_depth_image)

            json_file_path = "/home/vunknow/patroling_data/data.json"
            json_data = {}

            # Read existing JSON data if file exists
            if os.path.exists(json_file_path):
                with open(json_file_path, "r") as f:
                    try:
                        json_data = json.load(f)
                    except json.JSONDecodeError:
                        json_data = {}

            # Create pose key
            pose_key = f"{x:.3f}_{y:.3f}_{z:.3f}_{w:.3f}"

            # Create or update the pose entry
            if pose_key not in json_data:
                json_data[pose_key] = {
                    "pose": {
                        "x": x,
                        "y": y,
                        "z": z,
                        "w": w
                    },
                    "data": []
                }

            # Add new image data
            image_data = {
                "timestamp": timestamp,
                "robot_name": robot_name,
                "image_path": image_path,
                "depth_data_path": depth_npz_path  # Updated to reference NPZ file
            }

            json_data[pose_key]["data"].append(image_data)

            # Write updated data back to JSON file
            with open(json_file_path, "w") as f:
                json.dump(json_data, f, indent=4)
        else:
            if self.latest_depth_image is None:
                self.get_logger().error('Skipping: latest_depth_image is None')
            elif self.latest_image is None: 
                self.get_logger().error('Skipping: latest_image is None')
# Created/Modified files during execution:
# - /home/vunknow/patroling_data/images/images_{robot_name}_{timestamp}.jpg
# - /home/vunknow/patroling_data/depth_data/depth_data_{robot_name}_{timestamp}.csv
# - /home/vunknow/patroling_data/data.json


# Example usage:
# save_images_and_update_json(save_dir, robot_name, self.latest_image, self.latest_depth_image)

# Created/Modified files during execution:
# - data.json
# - {save_dir}/images_{robot_name}_{timestamp}.jpg
# - {save_dir}/depth_images_{robot_name}_{timestamp}.jpg


    def assign_new_monitoring_goal(self, robot_name):
        """
        Assigns a new monitoring point to the robot.
        """
        robot_obj = self.robot_manager.get_robot_by_id(robot_name)
        if not robot_obj:
            self.get_logger().error(f'Robot {robot_name} not found in RobotManager.')
            return

        # Assuming robot_obj.get_next_monitoring_point() returns a list or tuple
        next_point = np.asarray(robot_obj.get_next_monitoring_point())
        next_point = next_point.reshape(1, -1) 


        # Now perform the transformation
        next_point = self.convert_grid_to_world(
            Atransform(next_point, self.occupancy_grid.shape, self.get_logger())
        )
        # next_point = self.convert_grid_to_world(Atransform([robot_obj.get_next_monitoring_point()],self.occupancy_grid.shape, self.get_logger()))
        print("nextnext",next_point)
        if not next_point:
            self.get_logger().warn(f'No more monitoring points to assign for {robot_name}.')
            return

        pose = PoseStamped()
        pose.header.frame_id = self.world_frame
        pose.header.stamp = self.get_clock().now().to_msg()

        pose.pose.position.x = float(next_point[0][0])
        pose.pose.position.y = float(next_point[0][1])
        pose.pose.position.z = 0.0
        pose.pose.orientation.w = 1.0  # Facing forward

        # Log the coordinates of the goal position
        self.get_logger().info(f'Goal position for {robot_name}: x={pose.pose.position.x}, y={pose.pose.position.y}, z={pose.pose.position.z}')

        # Create a goal
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = pose

        action_client = self.robots[robot_name]['action_client']
        action_topic = f'/{robot_name}/navigate_to_pose'

        # Wait until the action server is available
        if not action_client.wait_for_server(timeout_sec=5.0):
            self.get_logger().error(f'Action server not available for {robot_name} at {action_topic}')
            return

        # Send goal
        self.get_logger().info(f'Sending patrol goal to {robot_name}: Point {next_point}')
        send_goal_future = action_client.send_goal_async(
            goal_msg,
            feedback_callback=lambda feedback: self.feedback_callback(robot_name, feedback)
        )
        send_goal_future.add_done_callback(lambda future: self.goal_response_callback(robot_name, future))
        robot_obj.current_goal = [pose.pose.position.x,pose.pose.position.y,pose.pose.position.z,pose.pose.orientation.w]
        # Update robot status
        self.robots[robot_name]['status'] = GoalStatus.STATUS_EXECUTING
        self.robots[robot_name]['assigned_point'] = pose.pose.position  # Assign the patrol goal
        self.robots[robot_name]['current_point'] = None

    def goal_response_callback(self, robot_name, future):
        """
        Callback after a goal is sent to a robot.
        """
        goal_handle = future.result()
        if not goal_handle.accepted:
            self.get_logger().info(f'Goal rejected for {robot_name}')
            self.robots[robot_name]['status'] = GoalStatus.STATUS_UNKNOWN
            self.robots[robot_name]['goal_handle'] = None
            return

        self.get_logger().info(f'Goal accepted for {robot_name}')
        self.robots[robot_name]['goal_handle'] = goal_handle
        self.robots[robot_name]['status'] = GoalStatus.STATUS_ACCEPTED

        # Get result asynchronously
        goal_handle.get_result_async().add_done_callback(lambda future: self.get_result_callback(robot_name, future))

    def get_result_callback(self, robot_name, future):
        """
        Callback to handle the result of a goal.
        """
        result = future.result().result
        status = future.result().status

        # Update robot's status
        self.robots[robot_name]['status'] = status

        status_str = self.get_status_string(status)
        self.get_logger().info(f'Goal status for {robot_name}: {status_str}')

        if status == GoalStatus.STATUS_SUCCEEDED:
            # if robot_name=="robot3":
            #     self.get_logger().info(f"savingsavingsavingsavingsavingsaving")
            #     self.saving_data(status=status,robot_name=robot_name)
            point = self.robots[robot_name]['assigned_point']
            self.get_logger().info(f'Goal succeeded for {robot_name}: Point {point}')
            self.robots[robot_name]['current_point'] = point

            # Optionally, handle point visitation (e.g., mark as visited)

            # Reset assigned point
            self.robots[robot_name]['assigned_point'] = None

            # Change robot state back to 'patrolling'
            robot_obj = self.robot_manager.get_robot_by_id(robot_name)
            ic(robot_name,"robot_name")

            ic(robot_obj.state,"before changing")
            if robot_obj:
                x,y = self.latest_positions[robot_name].x,self.latest_positions[robot_name].y
                robot_obj.position = x,y
                robot_obj.change_state('patrolling')
                ic(robot_obj.state,"after changing")
                ic(self.robot_manager.n_clusters,"n_clusters")
                self.robot_manager._divide_available_space()

                self.get_logger().info(f"Robot {robot_name} state changed back to 'patrolling'.")

        elif status in [GoalStatus.STATUS_ABORTED, GoalStatus.STATUS_CANCELED]:
            self.get_logger().warn(f'Goal for {robot_name} failed with status: {status_str}')

            # Change robot state back to 'patrolling' even if the goal failed
            robot_obj = self.robot_manager.get_robot_by_id(robot_name)
            if robot_obj:
                x,y = self.latest_positions[robot_name].x,self.latest_positions[robot_name].y
                robot_obj.position = x,y
                robot_obj.change_state('patrolling')
                # self.robot_manager._divide_available_space()

                self.get_logger().info(f"Robot {robot_name} state changed back to 'patrolling'.")

        else:
            self.get_logger().info(f'Goal for {robot_name} ended with status: {status_str}')

        # Reset the goal_handle to indicate that the robot is ready for a new goal
        self.robots[robot_name]['goal_handle'] = None

    def feedback_callback(self, robot_name, feedback_msg):
        """
        Optional: Process feedback from the action server.
        """
        # Example: Log the progress
        # self.get_logger().info(f'Feedback from {robot_name}: {feedback_msg.feedback}')
        pass

    def get_status_string(self, status):
        """
        Converts status code to human-readable string.
        """
        status_dict = {
            GoalStatus.STATUS_UNKNOWN: 'UNKNOWN',
            GoalStatus.STATUS_ACCEPTED: 'ACCEPTED',
            GoalStatus.STATUS_EXECUTING: 'EXECUTING',
            GoalStatus.STATUS_CANCELING: 'CANCELING',
            GoalStatus.STATUS_SUCCEEDED: 'SUCCEEDED',
            GoalStatus.STATUS_CANCELED: 'CANCELED',
            GoalStatus.STATUS_ABORTED: 'ABORTED'
        }
        return status_dict.get(status, f'UNKNOWN_STATUS_{status}')

    # ------------------- Marker Publishing for Rviz -------------------

    def publish_markers_each(self):
        """
        Publishes the monitoring points for each robot as separate MarkerArray messages with unique colors.
        """
        for robot_name, data in self.robots.items():
            robot_obj = self.robot_manager.get_robot_by_id(robot_name)

            marker_array = MarkerArray()
            current_time = self.get_clock().now().to_msg()

            marker = Marker()
            marker.header.frame_id = self.world_frame
            marker.header.stamp = current_time
            marker.ns = f"{robot_name}_monitoring_points"
            marker.id = 0
            marker.type = Marker.POINTS
            marker.action = Marker.ADD
            marker.pose.orientation.w = 1.0
            marker.scale.x = 0.2  # Size of the points
            marker.scale.y = 0.2
            marker.color.r, marker.color.g, marker.color.b, marker.color.a = data['color']
            
            # Add each monitoring point to the marker
            for point in self.convert_grid_to_world(Atransform(np.array(robot_obj.assigned_points), self.occupancy_grid.shape, self.get_logger())):

                # Assuming robot_obj.get_next_monitoring_point() returns a list or tuple

                # Now perform the transformation
                point_msg = Point()
                point_msg.x = float(point[0])
                point_msg.y = float(point[1])
                point_msg.z = 0.0
                marker.points.append(point_msg)

            marker_array.markers.append(marker)

            # Publish the marker array to the robot-specific topic
            data['marker_publisher'].publish(marker_array)
    
    def publish_markers(self):
        """
        Publishes the monitoring points as MarkerArray messages for Rviz visualization.
        This function is called periodically by a timer.
        """
        marker_array = MarkerArray()
        current_time = self.get_clock().now().to_msg()

        marker = Marker()
        marker.header.frame_id = self.world_frame
        marker.header.stamp = current_time
        marker.ns = "monitoring_points"
        marker.id = 0
        marker.type = Marker.POINTS
        marker.action = Marker.ADD
        marker.pose.orientation.w = 1.0
        marker.scale.x = 0.1  # Size of the points
        marker.scale.y = 0.1
        marker.color.r = 0.0
        marker.color.g = 1.0
        marker.color.b = 0.0
        marker.color.a = 1.0  # Fully opaque
        marker.points = []

        for point in self.monitoring_points_world:
            point_msg = Point()
            point_msg.x = float(point[0])
            point_msg.y = float(point[1])
            point_msg.z = 0.0
            marker.points.append(point_msg)

        marker_array.markers.append(marker)

        # Publish the markers
        self.pub_marker_points.publish(marker_array)


    # ------------------- New Method: Publish Robot Markers -------------------

    def publish_robot_markers(self):
        """
        Publishes markers for each robot on their respective topics with unique colors.
        """
        for robot_name, data in self.robots.items():
            marker = Marker()
            marker.header.frame_id = self.world_frame
            marker.header.stamp = self.get_clock().now().to_msg()
            marker.ns = f"{robot_name}_namespace"
            marker.id = 0  # Unique ID per robot
            marker.type = Marker.ARROW  # Use ARROW to indicate direction
            marker.action = Marker.ADD
            marker.pose.orientation.w = 1.0
            marker.scale.x = 1.0  # Arrow length
            marker.scale.y = 0.2  # Arrow width
            marker.scale.z = 0.2  # Arrow height
            marker.color.r, marker.color.g, marker.color.b, marker.color.a = data['color']

            # Determine the position to display the marker
            if data['assigned_point']:
                # If there's an assigned goal, show the goal position
                position = data['assigned_point']
                marker.pose.position.x = float(position.x)
                marker.pose.position.y = float(position.y)
                marker.pose.position.z = 0.0
                # Orientation can be set based on the robot's heading if available
            elif data['current_point']:
                # Else, show the current position
                position = data['current_point']
                marker.pose.position.x = float(position.x)
                marker.pose.position.y = float(position.y)
                marker.pose.position.z = 0.0
            else:
                # If no position is available, place the marker at origin
                marker.pose.position.x = 0.0
                marker.pose.position.y = 0.0
                marker.pose.position.z = 0.0

            # Optionally, set the orientation based on the robot's heading
            # For simplicity, we set it to face forward
            marker.pose.orientation.w = 1.0

            # Publish the marker
            data['marker_publisher'].publish(marker)

    # --------------------------------------------------------------------------

def main(args=None):
    rclpy.init(args=args)
    node = GoalAssignerNode()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
```



```vunknow@vunknow-ROG-Strix-G513RM-G513RM:~/ros2_ws$ ros2 launch patroling patrol_launch.py num_robots:=4
[INFO] [launch]: All log files can be found below /home/vunknow/.ros/log/2024-12-05-05-20-37-566062-vunknow-ROG-Strix-G513RM-G513RM-27628
[INFO] [launch]: Default logging verbosity is set to INFO
[INFO] [goal_assigner_node-1]: process started with pid [27630]
[goal_assigner_node-1] /home/vunknow/.local/lib/python3.10/site-packages/matplotlib/projections/__init__.py:63: UserWarning: Unable to import Axes3D. This may be due to multiple versions of Matplotlib being installed (e.g. as a system package and as a pip package). As a result, the 3D projection is not available.
[goal_assigner_node-1]   warnings.warn("Unable to import Axes3D. This may be due to multiple versions of "
[goal_assigner_node-1] [INFO] [1733356240.044994997] [goal_assigner]: ([-10, -22.8, 0], 963, 1058)
[goal_assigner_node-1] [INFO] [1733356240.951020041] [goal_assigner]: Loaded 5545 monitoring points.
[goal_assigner_node-1] [INFO] [1733356241.083534876] [goal_assigner]: Added robot robot1 at grid position [348, 314]
[goal_assigner_node-1] [INFO] [1733356241.091483475] [goal_assigner]: Added robot robot2 at grid position [232, 104]
[goal_assigner_node-1] [INFO] [1733356241.098610016] [goal_assigner]: Added robot robot3 at grid position [394, 277]
[goal_assigner_node-1] [INFO] [1733356241.105058061] [goal_assigner]: Added robot robot4 at grid position [577, 635]
[goal_assigner_node-1] [INFO] [1733356241.924087914] [goal_assigner]: Assigned 1402 points to robot robot1
[goal_assigner_node-1] [INFO] [1733356241.936137210] [goal_assigner]: Assigned 1349 points to robot robot2
[goal_assigner_node-1] [INFO] [1733356241.948225520] [goal_assigner]: Assigned 1391 points to robot robot3
[goal_assigner_node-1] [INFO] [1733356241.960341722] [goal_assigner]: Assigned 1403 points to robot robot4
[goal_assigner_node-1] [INFO] [1733356241.972703566] [goal_assigner]: Assigned 1402 points to robot robot1
[goal_assigner_node-1] [INFO] [1733356241.985195755] [goal_assigner]: Assigned 1349 points to robot robot2
[goal_assigner_node-1] [INFO] [1733356241.997879686] [goal_assigner]: Assigned 1391 points to robot robot3
[goal_assigner_node-1] [INFO] [1733356242.010145088] [goal_assigner]: Assigned 1403 points to robot robot4
[goal_assigner_node-1] [INFO] [1733356242.010730861] [goal_assigner]: Assigned 1402 monitoring points to robot1
[goal_assigner_node-1] [INFO] [1733356242.011198321] [goal_assigner]: Assigned 1349 monitoring points to robot2
[goal_assigner_node-1] [INFO] [1733356242.011657374] [goal_assigner]: Assigned 1391 monitoring points to robot3
[goal_assigner_node-1] [INFO] [1733356242.012091862] [goal_assigner]: Assigned 1403 monitoring points to robot4
[goal_assigner_node-1] [INFO] [1733356242.033611240] [goal_assigner]: Loaded objects from /home/vunknow/ros2_ws/src/patroling/config/objects.yaml
[goal_assigner_node-1] [INFO] [1733356242.042290554] [goal_assigner]: Subscribed to /robot1/odom
[goal_assigner_node-1] [INFO] [1733356242.051627796] [goal_assigner]: Subscribed to /robot2/odom
[goal_assigner_node-1] [INFO] [1733356242.060003709] [goal_assigner]: Subscribed to /robot3/odom
[goal_assigner_node-1] [INFO] [1733356242.068779925] [goal_assigner]: Subscribed to /robot4/odom
[goal_assigner_node-1] [INFO] [1733356244.016563048] [goal_assigner]: Assigning new patrol goal to robot1
[goal_assigner_node-1] [INFO] [1733356244.017151165] [goal_assigner]: Goal position for robot1: x=16.900000000000002, y=24.250000000000004, z=0.0
[goal_assigner_node-1] [INFO] [1733356244.018764972] [goal_assigner]: Sending patrol goal to robot1: Point [(16.900000000000002, 24.250000000000004)]
[goal_assigner_node-1] [INFO] [1733356244.019445072] [goal_assigner]: Assigning new patrol goal to robot2
[goal_assigner_node-1] [INFO] [1733356244.019904807] [goal_assigner]: Goal position for robot2: x=-2.1499999999999995, y=6.0, z=0.0
[goal_assigner_node-1] [INFO] [1733356244.020818707] [goal_assigner]: Sending patrol goal to robot2: Point [(-2.1499999999999995, 6.0)]
[goal_assigner_node-1] [INFO] [1733356244.021490331] [goal_assigner]: Assigning new patrol goal to robot3
[goal_assigner_node-1] [INFO] [1733356244.022114867] [goal_assigner]: Goal position for robot3: x=9.8, y=-10.3, z=0.0
[goal_assigner_node-1] [INFO] [1733356244.023975057] [goal_assigner]: Sending patrol goal to robot3: Point [(9.8, -10.3)]
[goal_assigner_node-1] [INFO] [1733356244.025101357] [goal_assigner]: Assigning new patrol goal to robot4
[goal_assigner_node-1] [INFO] [1733356244.025741482] [goal_assigner]: Goal position for robot4: x=21.150000000000002, y=7.350000000000001, z=0.0
[goal_assigner_node-1] [INFO] [1733356244.027161454] [goal_assigner]: Sending patrol goal to robot4: Point [(21.150000000000002, 7.350000000000001)]
[goal_assigner_node-1] [INFO] [1733356244.031382918] [goal_assigner]: Goal accepted for robot4
[goal_assigner_node-1] [INFO] [1733356244.032048000] [goal_assigner]: Goal accepted for robot3
[goal_assigner_node-1] [INFO] [1733356244.032578649] [goal_assigner]: Goal accepted for robot2
[goal_assigner_node-1] [INFO] [1733356244.033104729] [goal_assigner]: Goal accepted for robot1
[goal_assigner_node-1] [INFO] [1733356255.426049869] [goal_assigner]: Sending robot2 to object3 at position {'x': 4.0, 'y': -6.5}
[goal_assigner_node-1] [INFO] [1733356255.428833207] [goal_assigner]: Sending external goal to robot2
[goal_assigner_node-1] [INFO] [1733356256.256164723] [goal_assigner]: Assigned 1997 points to robot robot1
[goal_assigner_node-1] [INFO] [1733356256.266687856] [goal_assigner]: Assigned 1761 points to robot robot3
[goal_assigner_node-1] [INFO] [1733356256.278053766] [goal_assigner]: Assigned 1787 points to robot robot4
[goal_assigner_node-1] [INFO] [1733356256.278754454] [goal_assigner]: Robot robot2 state changed to 'working'.
[goal_assigner_node-1] [INFO] [1733356256.377584474] [goal_assigner]: Goal status for robot2: ABORTED
[goal_assigner_node-1] [WARN] [1733356256.378414095] [goal_assigner]: Goal for robot2 failed with status: ABORTED
[goal_assigner_node-1] [INFO] [1733356256.378938803] [goal_assigner]: Robot robot2 state changed back to 'patrolling'.
[goal_assigner_node-1] [INFO] [1733356256.379540234] [goal_assigner]: Goal accepted for robot2
[goal_assigner_node-1] [INFO] [1733356300.141492544] [goal_assigner]: Goal status for robot2: SUCCEEDED
[goal_assigner_node-1] [INFO] [1733356300.142121408] [goal_assigner]: Goal succeeded for robot2: Point geometry_msgs.msg.Point(x=4.0, y=-6.5, z=0.0)
[goal_assigner_node-1] ic| robot_name: 'robot2', 'robot_name'
[goal_assigner_node-1] ic| robot_obj.state: 'patrolling', 'before changing'
[goal_assigner_node-1] ic| robot_obj.state: 'patrolling', 'after changing'
[goal_assigner_node-1] ic| self.robot_manager.n_clusters: 4, 'n_clusters'
[goal_assigner_node-1] [INFO] [1733356301.223063046] [goal_assigner]: Assigned 1410 points to robot robot1
[goal_assigner_node-1] [INFO] [1733356301.236318761] [goal_assigner]: Assigned 1351 points to robot robot2
[goal_assigner_node-1] [INFO] [1733356301.250212888] [goal_assigner]: Assigned 1399 points to robot robot3
[goal_assigner_node-1] [INFO] [1733356301.263308622] [goal_assigner]: Assigned 1385 points to robot robot4
[goal_assigner_node-1] [INFO] [1733356301.263850191] [goal_assigner]: Robot robot2 state changed back to 'patrolling'.
[goal_assigner_node-1] [INFO] [1733356302.016892375] [goal_assigner]: savingsavingsaving
[goal_assigner_node-1] [ERROR] [1733356302.017354374] [goal_assigner]: Skipping: latest_depth_image is None
[goal_assigner_node-1] [INFO] [1733356302.017807176] [goal_assigner]: Assigning new patrol goal to robot2
[goal_assigner_node-1] [INFO] [1733356302.018367521] [goal_assigner]: Goal position for robot2: x=-4.1499999999999995, y=6.0, z=0.0
[goal_assigner_node-1] [INFO] [1733356302.020607306] [goal_assigner]: Sending patrol goal to robot2: Point [(-4.1499999999999995, 6.0)]
[goal_assigner_node-1] [INFO] [1733356302.022638969] [goal_assigner]: Goal accepted for robot2
^C[WARNING] [launch]: user interrupted with ctrl-c (SIGINT)
```



so i send a request thry service to give robot2 external goal what happened was it got the nav2 goal but printed abort and still went to the goal and after going there it loged that new goal accepted and exactly at same moment goal succeded why is i aborting?